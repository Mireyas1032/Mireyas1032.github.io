---
title: "Assignment 2"
format: 
  revealjs:
    transition: slide
---

## **Relation Schema, Relation, and Instance**{.smaller}

A **relation schema** consists of a list of attributes and their corresponding domains. For example, the relation schema of `department` is:

`department (dept_name, building. budget)`

The term **relation** is used to refer to a table. A relation has multiple rows called tuples and columns called attributes. For example, the `prereq` relation will have a `course_id` attribute and a `prereq_id` attribute with multiple tuples showing the ID numbers.

An **instance** refers to a specific instance of a relation containing a specific set of rows. For example: the instance of `instructor` has 12 tuples corresponding to 12 instructors

## Bank Database Schema

```{r}
library(DiagrammeR)

grViz("
digraph bank_schema {
  graph [rankdir=LR, splines=ortho]
  node  [shape=plain, fontname=Helvetica]
  edge  [fontname=Helvetica]

  branch [
    label=<
      <table border='1' cellborder='0' cellspacing='0' cellpadding='6'>
        <tr><td bgcolor='#f2f2f2'><b>branch</b></td></tr>
        <tr><td align='left'><b>PK</b> branch_name</td></tr>
        <tr><td align='left'>branch_city</td></tr>
        <tr><td align='left'>assets</td></tr>
      </table>
    >
  ]

  customer [
    label=<
      <table border='1' cellborder='0' cellspacing='0' cellpadding='6'>
        <tr><td bgcolor='#f2f2f2'><b>customer</b></td></tr>
        <tr><td align='left'><b>PK</b>customer_name</td></tr>
        <tr><td align='left'>ID</td></tr>
        <tr><td align='left'>customer_street</td></tr>
        <tr><td align='left'>customer_city</td></tr>
      </table>
    >
  ]

  loan [
    label=<
      <table border='1' cellborder='0' cellspacing='0' cellpadding='6'>
        <tr><td bgcolor='#f2f2f2'><b>loan</b></td></tr>
        <tr><td align='left'><b>PK</b> branch_name</td></tr>
        <tr><td align='left'><b>FK</b> loan_number</td></tr>
        <tr><td align='left'>amount</td></tr>
      </table>
    >
  ]

  account [
    label=<
      <table border='1' cellborder='0' cellspacing='0' cellpadding='6'>
        <tr><td bgcolor='#f2f2f2'><b>account</b></td></tr>
        <tr><td align='left'><b>PK</b> branch_name</td></tr>
        <tr><td align='left'><b>FK</b> account_number</td></tr>
        <tr><td align='left'>balance</td></tr>
      </table>
    >
  ]

  borrower [
    label=<
      <table border='1' cellborder='0' cellspacing='0' cellpadding='6'>
        <tr><td bgcolor='#f2f2f2'><b>borrower</b></td></tr>
        <tr><td align='left'><b>FK</b> loan_number</td></tr>
        <tr><td align='left'>ID</td></tr>
      </table>
    >
  ]

  depositor [
    label=<
      <table border='1' cellborder='0' cellspacing='0' cellpadding='6'>
        <tr><td bgcolor='#f2f2f2'><b>depositor</b></td></tr>
        <tr><td align='left'><b>FK</b> account_number</td></tr>
        <tr><td align='left'>ID</td></tr>
      </table>
    >
  ]

  loan     -> branch
  account  -> branch

  borrower -> customer
  borrower -> loan

  depositor -> customer
  depositor -> account
}
")
```

## AI for databases {.smaller}

AI can clean data by detecting missing values, incorrect data, and inconsistent formats. AI can detect unusual patterns automticaly while traditional methods rely on fixed rules. Not only can it detect, but it can also suggest corrections based on context. The same can be done with duplicate records. AI can learn patterns from the data to detect duplicates, while traditional methods require manually defined rules.

Large Language Models also allows user to query a database using plain English instead of writing SQL code. LLM's can analyze the database schema and map natural language phrases to schema alerts to generate SQL. Traditional methods require users to understand SQL syntax and schema structure, but AI requires no prior experience and can even create query's faster with fewer mistakes.
